<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>尚硅谷谷粒后台管理系统</title>
      <link href="/2022/react-project-summary/"/>
      <url>/2022/react-project-summary/</url>
      
        <content type="html"><![CDATA[<h2 id="1-项目介绍"><a href="#1-项目介绍" class="headerlink" title="1. 项目介绍"></a>1. 项目介绍</h2><h3 id="1-1-项目描述"><a href="#1-1-项目描述" class="headerlink" title="1.1 项目描述"></a>1.1 项目描述</h3><ol><li>此项目为一个前后台分离的后台管理的 SPA, 包括前端 PC 应用和后端应用</li><li>包括用户管理 / 商品分类管理 / 商品管理 / 权限管理等功能模块</li><li>前端: 使用 React 全家桶 + Antd + Axios + ES6 + Webpack 等技术</li><li>后端: 使用 Node + Express + Mongodb 等技术</li><li>采用模块化、组件化、工程化的模式开发</li></ol><h3 id="1-2-项目功能界面"><a href="#1-2-项目功能界面" class="headerlink" title="1.2 项目功能界面"></a>1.2 项目功能界面</h3><p>在线预览地址：<a href="http://120.25.207.68:5000/">点击这里</a></p><h3 id="1-3-技术选型"><a href="#1-3-技术选型" class="headerlink" title="1.3 技术选型"></a>1.3 技术选型</h3><p><img src="0.png" alt="技术选型"></p><h3 id="1-4-前端路由"><a href="#1-4-前端路由" class="headerlink" title="1.4 前端路由"></a>1.4 前端路由</h3><p><img src="1.png" alt="路由"></p><h3 id="1-5-项目源码文件结构"><a href="#1-5-项目源码文件结构" class="headerlink" title="1.5 项目源码文件结构"></a>1.5 项目源码文件结构</h3><p><img src="2.png" alt="文件结构"></p><h2 id="2-常用命令"><a href="#2-常用命令" class="headerlink" title="2. 常用命令"></a>2. 常用命令</h2><h3 id="2-1-npm-yarn-常用命令"><a href="#2-1-npm-yarn-常用命令" class="headerlink" title="2.1 npm/yarn 常用命令"></a>2.1 npm/yarn 常用命令</h3><p>yarn 命令文档：<a href="https://yarn.bootcss.com/docs/cli/">https://yarn.bootcss.com/docs/cli/</a></p><p>npm 命令文档：<a href="https://docs.npmjs.com/cli/v8/commands">https://docs.npmjs.com/cli/v8/commands</a></p><p>设置淘宝镜像：</p><p><code>npm config set registry https://registry.npm.taobao.org</code></p><p><code>yarn config set registry https://registry.npm.taobao.org</code></p><p>初始化项目：</p><p><code>yarn init -y</code></p><p><code>npm init -y</code></p><p>下载项目的所有声明的依赖：</p><p><code>yarn install</code></p><p><code>npm install</code></p><p>下载指定的运行时依赖包：</p><p><code>yarn add package-name@3.2.1 </code></p><p><code>npm install package-name@3.2.1 -S</code></p><p>下载指定的开发时依赖:：</p><p><code>yarn add package-name@3.2.1 -D </code></p><p><code>npm install package-name@3.2.1 -D</code></p><p>全局下载指定包：</p><p><code>yarn global add package-name</code></p><p><code>npm install package-name-g</code></p><p>删除依赖包：</p><p><code>yarn remove package-name</code>, <code>yarn global remove package-name</code></p><p><code>npm uninstall package-name</code>, <code>npm uninstall package-name-g</code></p><p>运行项目中配置的 script：</p><p><code>yarn run xxx</code></p><p><code>npm run xxx</code></p><h3 id="2-2-git-常用命令"><a href="#2-2-git-常用命令" class="headerlink" title="2.2 git 常用命令"></a>2.2 git 常用命令</h3><p>Git 在线参考手册：<a href="http://gitref.justjavac.com/">http://gitref.justjavac.com/</a></p><p><code>git init</code> //初始化生成一个本地仓库<br><code>git add .</code> //添加到暂存区<br><code>git commit –m "message"</code> //提交到本地仓库<br><code>git remote add origin url</code> //关联到远程仓库<br><code>git push origin master</code> //推送本地 master 分支到远程 master 分支<br><code>git checkout -b dev</code> //创建一个开发分支并切换到新分支<br><code>git push origin dev </code> //推送本地 dev 分支到远程 dev 分支<br><code>git clone url</code> //将远程仓库克隆下载到本地<br><code>git checkout -b dev origin/dev</code> // 克隆仓库后切换到 dev 分支<br><code>git pull origin dev</code> //从远程 dev 分支拉取到本地 dev 分支</p><h2 id="3-学习记录"><a href="#3-学习记录" class="headerlink" title="3. 学习记录"></a>3. 学习记录</h2><p>记录一些开发经验和初次使用 React 开发项目时遇到的问题。</p><h3 id="3-1-项目开发相关"><a href="#3-1-项目开发相关" class="headerlink" title="3.1 项目开发相关"></a>3.1 项目开发相关</h3><ul><li><p>封装 axios 请求；配置代理服务器解决 ajax 请求跨域问题；</p></li><li><p>优化了获取默认需要展开的子菜单（适用于多级子菜单，使用了回溯算法）；</p></li><li><p>优化了 Category 组件的编码；在 Category 组件中拆分出两个表单组件；</p></li><li><p>级联选择框默认选中数组 category 好像要在 options 初始化之前填充，否则貌似不生效；</p></li><li><p>添加商品和修改商品共用一个组件，根据是否向路由组件传递 product 对象来展示不同的内容；</p></li><li><p>postman 发送 post 请求时请求体的参数类型一般为 form-urlencoded，上传图片时请求体参数类型为 form-data；</p></li><li><p>上传图片的流程：upload 组件上传图片后将后台生成的 name 属性和 url 属性作为上传文件的 name，url 属性存储起来，url 由前缀加上 name 生成；更新商品时需要默认显示商品图片，商品的 imgs 属性中存储了之前的 name 属性值，由 name 属性值可得到 url，即可展示商品图片；</p></li><li><p>useNavigate 函数式路由跳转适合用于组件渲染后；Navigate 标签式路由跳转适合用于组件渲染之前；</p></li><li><p>函数组件不能给其设置 ref 属性，使用 forwardRef 和 useImperativeHandle 可给函数组件设置 ref 属性，用于父组件获取子组件中的表单数据等；使用 useImperativeHandle 用于子组件向父组件传值；</p></li><li><p>Effect Hook 用法：使用 setInterval 显示当前时间，这是一个需要清除的副作用，（还有其他的比如订阅消息），这些需要清除的副作用可能会变化，举个例子，在组件挂载后订阅好友的状态，并在卸载组件的时候取消订阅，期间我们可能会更新订阅，如果使用 class 定义组件就要在 componentDidUpdate 生命周期中，取消之前的订阅，订阅新的，（这样做的目的是防止引用丢失，类比 setInterval），如果使用 Effect Hook 将清除阶段写在回调函数中就很方便，effect 的清除阶段在每次重新渲染时都会执行，而不是只在卸载组件的时候执行一次；</p></li><li><p>Ref Hook 不仅可以用于 DOM refs。「ref」 对象是一个 current 属性可变且可以容纳任意值的通用容器，类似于一个 class 的实例属性；</p></li><li><p>函数组件内普通变量和 useState 和 useRef 的用法：当变量不会发生变化时使用 var 声明使用即可，当变量会发生变化时使用 useRef，当变量会发生变化且会引起页面内容的变化时使用 useState；</p></li><li><p>setState 在 react 相关的函数中执行是异步的（事务机制？）多次 setState 只会执行一次 render（重新渲染）；其他情况（如定时器）执行是同步的；setState 传入函数时，参数一定是最新的 state；</p></li><li><p>搭建 redux 开发环境：</p></li></ul><ol><li>安装依赖：yarn add redux react-redux redux-thunk redux-devtools-extension；</li><li>在 src 目录下创建 redux 文件夹，并在该文件夹下创建 store, reducer, actions, action-types 这些 js 文件，并初始化代码；</li><li>在项目入口 index.js 文件中引入 Provider 组件并传入 store 属性以应用 redux；</li><li>在 action.js 中创建工厂函数生成 action；用 connect 函数连接 UI 组件和 redux，函数中向 UI 组件中传入 store 中的 state 和 action 中的工厂函数（用于生成 action 并修改 store 中的 state）；</li></ol><ul><li><p>生产环境解决跨域问题：用 webpack 配置代理服务器，将前台的请求转发给代理服务器（与前台端口号相同，不存在跨域问题），由服务器请求后台接口，并将结果返回给前台；</p></li><li><p>开发环境解决跨域问题：</p></li></ul><ol><li>如果前台项目和后台项目独立运行（打包后执行 serve build 运行 build 目录下的前台应用），则使用 nginx 反向代理服务器，访问 nginx 服务器 8889 端口号，服务器会根据请求的路径区分前台路由还是后台路由，但使用 BrowserRouter 时会出现页面刷新时 404 问题；</li><li>如果前台项目打包后和后台项目在同一端口号运行（即将打包后 build 文件夹中的文件放在后台项目 node 的 public 文件夹下），则不存在跨域问题，但是需要解决使用 BrowserRouter 出现的问题。a. 问题：页面刷新时会出现 404 （找不到服务器资源）的错误；b. 原因：项目根路径后的 path 路径会被当作后台路由路径, 去请求对应的后台路由, 但没有相应路由；c. 解决：使用自定义中间件（如果 URL 不匹配任何静态资源，它应提供与你的应用程序中的 index.html 相同的页面）；注：如果使用 BrowserRouter 则不会出现 404 的错误，因为 # 后面的 URL 不会发送到服务器，一直请求的是 / 根路径下资源，服务器返回 index.html ；</li></ol><ul><li><p>使用 redux 遇到的问题：redux 中存储了头部标题的数据 headTitle，点击左侧的菜单项时，头部标题发生相应的变化，但是出现了如下报错：<img src="3.png" alt="Chrome Console"> 报错信息表示在渲染 LeftNav 组件的同时不能更新 Header 组件，要我在正确的位置更新数据 setState()；于是我找到 LeftNav 组件，发现我确实在渲染组件的时候调用了更新 redux 中状态的函数，<code>props.setHeadTitle(title)</code>，而 Header 组件中读取了 redux 中的该状态，所以控制台报这样的错误；于是我采用了另一种方法更新 redux 中的状态：在渲染 LeftNav 组件时先将需要更新的数据使用 useRef()存储起来，然后在 useEffect()中即组件挂载之后更新 redux 中的状态，果然修改之后就没有报错了；</p></li><li><p>使用 jsonp 请求天气信息，暂未实现该功能；</p></li><li><p>存在的 bug：修改用户名后会出现重名的情况；</p></li></ul><h3 id="3-2-部署上线相关"><a href="#3-2-部署上线相关" class="headerlink" title="3.2 部署上线相关"></a>3.2 部署上线相关</h3><ul><li>一个网站部署上线的步骤：</li></ul><ol><li>准备云服务器，Xshell</li><li>用 Xshell 连接远程主机，连接成功后在终端下安装宝塔面板管理服务器；</li><li>在阿里云服务器上开启 3306 端口(mysql),8888 端口(宝塔面板),8889 端口(后台 api 接口)，宝塔面板也要开启 3306 和 8889 端口；</li><li>在宝塔面板创建数据库并导入数据库文件，后台 api 接口文件(修改数据库连接参数、app.js 中监听的端口号 8889)；</li><li>在 pm2 管理器下添加项目用于开启服务器应用，应用启动后用 postman 进行接口测试；</li><li>修改前台应用的请求基准地址，重新打包；在宝塔添加站点并将打包后的文件放在站点的根目录下；</li></ol><blockquote><p>注：这是前后台应用在不同端口运行的做法，这次的项目由于跨域问题前后台应用在同一端口运行。</p></blockquote><ul><li><p>在服务器端将数据导入 mongodb：进入 mongodb 的安装目录，<code>cd /www/server/mongodb/bin</code>，为了方便将 json 文件复制到 bin 目录下，接着将数据导入数据库中，<code>mongoimport -d server_db2 -c categorys --jsonArray categorys.json -u username -p password</code>，参数说明：-d 指明使用的库, 本例中为” server_db2”，-c 指明要导入的表, 本例中为”categorys”，categorys.json 为数据文件，导入数据的时候会隐式创建表结构；导入成功后如下图所示：<img src="4.png">执行 mongo 命令启动服务，执行<code>use server_db2</code>进入 server_db2 数据库，<code>db.auth('username','password')</code>输入用户名和密码以授权，执行<code>db.categorys.find().pretty()</code>来查看表内的数据，可以看到表内确实成功导入了数据；<img src="5.png"></p></li><li><p>部署上线时遇到的问题：</p></li></ul><ol><li>服务器端连接并配置 mongodb；解决方法：<a href="https://segmentfault.com/a/1190000040037436">https://segmentfault.com/a/1190000040037436</a></li><li>一个 ip 怎么部署多个项目；解决方法：<a href="https://blog.csdn.netweixin_51560103/article/details/121202456">https://blog.csdn.net/weixin_51560103/article/details/121202456</a></li><li>跨域问题；解决方法：前后台应用放在同一端口号运行；使用 nginx 做反向代理也可，不过使用 BrowserRouter 时会出现页面刷新时 404 问题；</li><li>访问网站时 403；<a href="https://www.idcnote.com/bt/37.html">https://www.idcnote.com/bt/37.html</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> React </tag>
            
            <tag> Antd </tag>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flex 布局</title>
      <link href="/2022/flexlayout/"/>
      <url>/2022/flexlayout/</url>
      
        <content type="html"><![CDATA[<h2 id="Writing…"><a href="#Writing…" class="headerlink" title="Writing…"></a>Writing…</h2>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flex </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二叉树的遍历</title>
      <link href="/2021/binary-tree-traversal/"/>
      <url>/2021/binary-tree-traversal/</url>
      
        <content type="html"><![CDATA[<h2 id="1-二叉树介绍"><a href="#1-二叉树介绍" class="headerlink" title="1. 二叉树介绍"></a>1. 二叉树介绍</h2><p>在计算机科学中，二叉树（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。通常分支被称作“左子树”或“右子树”。二叉树的分支具有左右次序，不能随意颠倒。二叉树通常作为数据结构应用，典型用法是对节点定义一个标记函数，将一些值与每个节点相关系。这样标记的二叉树就可以实现二叉搜索树和二叉堆，并应用于高效率的搜索和排序。</p><p>二叉树是一种常见的数据结构，关于对二叉树的操作无外乎就是对它进行遍历。二叉树的遍历有<strong>前序、中序、后序、层序</strong>四种遍历方式，其中前三种也称为深度优先遍历，层序遍历也称为广度优先遍历。</p><p><img src="0.png" alt="Binary tree"></p><h2 id="2-深度优先遍历"><a href="#2-深度优先遍历" class="headerlink" title="2. 深度优先遍历"></a>2. 深度优先遍历</h2><p>深度优先遍历通常有递归和迭代两种解法。以一个题为例：<strong>给定一个二叉树的根节点 root ，以数组的形式返回它的 前、中、后 遍历的结果。</strong></p><p><img src="1.png" alt="示例"></p><p>前序遍历结果：<code>[1, 2, 3]</code><br>中序遍历结果：<code>[1, 3, 2]</code><br>后序遍历结果：<code>[3, 2, 1]</code></p><h3 id="2-1-递归解法"><a href="#2-1-递归解法" class="headerlink" title="2.1 递归解法"></a>2.1 递归解法</h3><pre class=" language-TypeScript"><code class="language-TypeScript">/** * Definition for a binary tree node. * class TreeNode { *     val: number *     left: TreeNode | null *     right: TreeNode | null *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) { *         this.val = (val===undefined ? 0 : val) *         this.left = (left===undefined ? null : left) *         this.right = (right===undefined ? null : right) *     } * } */function preorderTraversal(root: TreeNode | null): number[] {    // 递归，时间O(n), 空间O(n)    const res: number[] = []    function visit(node: TreeNode): void{        res.push(node.val)    }    function dfs(node: TreeNode | null): void{        if(node === null)   return        // 前序遍历写在这        visit(node)        dfs(node.left)        // 中序遍历写在这        // visit(node)        dfs(node.right)        // 后序遍历写在这        // visit(node)    }    dfs(root)    return res}</code></pre><p>对于前序、中序和后序遍历，只需将递归函数里的 visit 函数放在不同位置即可，其他的代码完全一样。</p><h3 id="2-2-迭代解法"><a href="#2-2-迭代解法" class="headerlink" title="2.2 迭代解法"></a>2.2 迭代解法</h3><h4 id="2-2-1-前序遍历"><a href="#2-2-1-前序遍历" class="headerlink" title="2.2.1 前序遍历"></a>2.2.1 前序遍历</h4><pre class=" language-TypeScript"><code class="language-TypeScript">function preorderTraversal(root: TreeNode | null): number[] {    // 迭代    function visit(node: TreeNode): void{        res.push(node.val)    }    const res: number[] = []    // 初始化栈    const stack: TreeNode[] = []    // cur是遍历指针    var cur: TreeNode = root    while(cur !== null || stack.length !== 0){        while(cur !== null){            // 将根节点 cur 和所有的左孩子入栈并加入结果中，直至 cur 为空            visit(cur)            stack.push(cur)            cur = cur.left        }        // 每弹出一个栈顶元素 temp，就到达它的右孩子        var temp: TreeNode = stack.pop()        cur = temp.right    }    return res}</code></pre><h4 id="2-2-2-中序遍历"><a href="#2-2-2-中序遍历" class="headerlink" title="2.2.2 中序遍历"></a>2.2.2 中序遍历</h4><p>和前序遍历的代码完全相同，只是在出栈的时候才将节点 temp 的值加入到结果中。</p><pre class=" language-TypeScript"><code class="language-TypeScript">function inorderTraversal(root: TreeNode | null): number[] {    function visit(node: TreeNode): void{        res.push(node.val)    }    const res: number[] = []    const stack: TreeNode[] = []    var cur: TreeNode = root    while(cur !== null || stack.length !== 0){        while(cur !== null){            stack.push(cur)            cur = cur.left        }        var temp: TreeNode = stack.pop()        visit(temp)        cur = temp.right    }    return res}</code></pre><h4 id="2-2-3-后序遍历"><a href="#2-2-3-后序遍历" class="headerlink" title="2.2.3 后序遍历"></a>2.2.3 后序遍历</h4><p>继续按照上面的思想，这次我们反着思考，节点 cur 先到达最右端的叶子节点并将路径上的节点入栈；然后每次从栈中弹出一个元素后，cur 到达它的左孩子，并将左孩子看作 cur 继续执行上面的步骤。最后将结果反向输出即可。</p><pre class=" language-TypeScript"><code class="language-TypeScript">function postorderTraversal(root: TreeNode | null): number[] {    function visit(node: TreeNode): void{        res.push(node.val)    }    const res: number[] = []    const stack: TreeNode[] = []    var cur: TreeNode = root    while(cur !== null || stack.length !== 0){        while(cur !== null){            // 先到达最右端            visit(cur)            stack.push(cur)            cur = cur.right        }        // 每弹出一个栈顶元素 temp，就到达它的左孩子        var temp: TreeNode = stack.pop()        cur = temp.right    }    return res.reverse() // 反向输出}</code></pre><h2 id="3-广度优先遍历"><a href="#3-广度优先遍历" class="headerlink" title="3. 广度优先遍历"></a>3. 广度优先遍历</h2><p>二叉树的广度优先遍历一般采用迭代方法，与前面深度优先遍历的迭代方法实现有所不同。前面的迭代方法都使用栈实现，而广度优先遍历使用队列实现。以一个题为例：<strong>给你一个二叉树，请你返回其按 层序遍历 得到的节点值。 （即逐层地，从左到右访问所有节点）。</strong></p><p><strong>示例：</strong><br>二叉树：</p><p><img src="2.png" alt="示例"></p><p><strong>返回其层序遍历结果：</strong><br><code>[ [3], [9,20], [15,7] ]</code></p><p>广度优先遍历的步骤为：</p><ol><li>初始化队列 q，并将根节点 root 加入到队列中；</li><li>当队列不为空时：<br>队列中弹出节点 node，加入到结果中；<br>如果左子树非空，左子树加入队列；<br>如果右子树非空，右子树加入队列；</li></ol><pre class=" language-TypeScript"><code class="language-TypeScript">/** * Definition for a binary tree node. * class TreeNode { *     val: number *     left: TreeNode | null *     right: TreeNode | null *     constructor(val?: number, left?: TreeNode | null, right?: TreeNode | null) { *         this.val = (val===undefined ? 0 : val) *         this.left = (left===undefined ? null : left) *         this.right = (right===undefined ? null : right) *     } * } */function levelOrder(root: TreeNode | null): number[][] {    if (root == null) {        return []    }    let result: number[][] = []    let queue: TreeNode[] = [root]    while (queue.length) {        // 每一层的节点数        let level: number = queue.length        let currLevel: number[] = []        // 每次遍历一层元素        for (let i = 0; i < level; i++) {            // 当前访问的节点出队            let curr: TreeNode = queue.shift()            // 出队节点的子女入队            if (curr.left) queue.push(curr.left)            if (curr.right) queue.push(curr.right)            currLevel.push(curr.val)        }        result.push(currLevel)    }    return result};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Node.js模块化开发</title>
      <link href="/2021/commonjs/"/>
      <url>/2021/commonjs/</url>
      
        <content type="html"><![CDATA[<h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3><p>JavaScript 原生态是一个全局的世界。所有如 setTimeout、document 等这样在浏览器端使用的 API，都是全局定义的。当我们在 html 文档中使用 script 标签引入第三方模块时，会引入该模块暴露出来的全局变量，这会导致对全局命名空间的污染和命名冲突的问题。Node 采用了 CommonJS 模块化规范。该模块系统有三个核心的全局对象：require、module 和 exports。</p><h4 id="绝对模块和相对模块"><a href="#绝对模块和相对模块" class="headerlink" title="绝对模块和相对模块"></a>绝对模块和相对模块</h4><p>绝对模块是指 node 通过在其内部 node_modules 查找到的模块，或者 node 内置的如 fs 这样的模块。可以直接通过名字来 require 这个模块，无需添加路径名：<code>var fs = require('fs')</code>，这里由于 fs 模块暴露了一系列操作文件系统的方法，所以在引入时用变量接收一下这个对象。有些模块没有暴露 API，则直接引入即可，无需用变量接收。</p><p>相对模块将 require 指向一个相对工作目录中的 Javascript 文件。在引入时需要添加相对路径名。</p><h4 id="暴露-API"><a href="#暴露-API" class="headerlink" title="暴露 API"></a>暴露 API</h4><p>要让模块暴露一个 API 成为 require 调用的返回值，就要依靠 module 和 exports 这两个全局变量。</p><p>默认情况下，每个模块都会暴露出一个名为 exports 的空对象，我们可以在该对象中添加属性。例如：</p><p><code>module_a.cjs</code></p><pre class=" language-javascript"><code class="language-javascript">exports<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"john"</span><span class="token punctuation">;</span><span class="token keyword">var</span> number <span class="token operator">=</span> <span class="token number">888</span><span class="token punctuation">;</span>exports<span class="token punctuation">.</span>getName <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">return</span> number<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p><code>index.cjs</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./module_a.cjs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// john</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 888</span></code></pre><ol><li><p>当我们在 index.cjs 中 require 导入的时候，它会去自动查找特殊的全局对象 exports，并且把 require 函数的执行结果赋值给 a;</p></li><li><p>a 和 exports 指向同一个引用(引用地址相同);</p></li><li><p>由于我们在 exports 对象上添加了属性，所以在 a 对象也可以访问到这些属性；</p></li></ol><p><strong>exports 其实是对 module.exports 的引用，实际导出的是 module.exports，</strong>其在默认情况下是一个对象。如果默认导出该对象无法满足需求，则可以重写 module.exports。</p><p><code>person.cjs</code></p><pre class=" language-javascript"><code class="language-javascript">module<span class="token punctuation">.</span>exports <span class="token operator">=</span> Person<span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>index.cjs</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> Person <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">"./person.cjs"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token string">"tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>person<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// tom</span></code></pre><blockquote><p>注意：如果多次使用 module.exports，则后面的会覆盖前面的导出对象。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Node.js </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>动态规划</title>
      <link href="/2021/dplan/"/>
      <url>/2021/dplan/</url>
      
        <content type="html"><![CDATA[<h3 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h3><p>一般来说，利用动态规划求解问题可以分为以下几个基本步骤：</p><ol><li>定义子问题；</li><li>建立各个子问题之间的递归关系；</li><li>自底向上求解递归式；</li><li>组合所有子问题的解从而获得原问题的解；</li></ol><h3 id="一维动态规划问题"><a href="#一维动态规划问题" class="headerlink" title="一维动态规划问题"></a>一维动态规划问题</h3><p><strong>打家劫舍</strong></p><p>你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，<strong>如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。</strong></p><p>给定一个代表每个房屋存放金额的非负整数数组，计算你 <strong>不触动警报装置的情况下</strong> ，一夜之内能够偷窃到的最高金额。</p><p><strong>输入：</strong>[2, 7, 9, 3, 1]<br><strong>输出：</strong>12<br><strong>解释：</strong>偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。<br>&nbsp; 偷窃到的最高金额 = 2 + 9 + 1 = 12 。</p><p>来源：力扣（LeetCode）</p><p>求解问题的步骤：</p><ol><li><p><strong>定义子问题</strong><br>子问题就是把原问题的规模缩小，例如此题的子问题就是“从前 k 个房子中能偷到的最大金额”，用 f(k) 表示。</p></li><li><p><strong>建立各个子问题之间的递归关系</strong><br>我们从第 k 间房子开始分析，如果不偷这个房子，那么问题就变成在前 k−1 个房子中偷到最大的金额，也就是子问题 f(k−1)。如果偷这个房子，那么前一个房子不能偷，那么问题就变成在前 k−2 个房子中偷到的最大的金额。两种情况中，选择金额较大的一种结果。<br>通过分析得到子问题之间的递归关系：<br><code>f(k) = max{ f(k-1), H(k) + f(k-2) }</code>，H(k)为第 k 间房的金额</p></li><li><p><strong>自底向上求解递归式</strong><br>自底向上构造一维动态规划表，初始化表为<code>f(0) = 0, f(1) = H(1)</code>，其他的项根据递归关系得出。</p></li><li><p><strong>组合所有子问题的解从而获得原问题的解</strong><br>此题原问题的解就是动态规划表的最后一项的值。</p></li></ol><p>代码实现：</p><pre class=" language-TypeScript"><code class="language-TypeScript">// 自底向上实现递归策略function rob(nums: number[]): number[] {  const len: number = nums.length;  if (len === 0) {    return [0];  }  // 子问题：  // f(k) = 偷 [0..k) 房间中的最大金额  // f(0) = 0  // f(1) = nums[0]  // f(k) = max{ rob(k-1), nums[k-1] + rob(k-2) }  const dp: Array<number> = new Array(len + 1).fill(0);  // 表格初始化  dp[0] = 0;  dp[1] = nums[0];  for (let k: number = 2; k <= len; k++) {    // 填表    dp[k] = Math.max(dp[k - 1], dp[k - 2] + nums[k - 1]);  }  return dp;}</code></pre><p><strong>复杂度分析</strong></p><p>时间复杂度：O(n)<br>空间复杂度：O(n)</p><p>此外如果需要返回到底偷窃了那几家房子，可以根据表的值得到解。</p><pre class=" language-TypeScript"><code class="language-TypeScript">// 回溯得到偷窃的最优解function trace_back(dp: number[]): number[] {  const res: number[] = new Array();  var i = dp.length - 1;  // 从dp表最后一项开始求解  while (i >= 1) {    // 如果该项大于前一项说明该房间被偷窃    if (dp[i] > dp[i - 1]) {      res.push(i);      i -= 2;    } else {      i -= 1;    }  }  return res.sort((a, b) => a - b);}var coins: number[] = [2, 7, 9, 3, 1];var dp: number[] = rob(coins);var res: number[] = trace_back(dp);console.log("动态规划表：", dp);console.log("偷窃的房间：", res);</code></pre><p><strong>测试用例：</strong>[2, 7, 9, 3, 1]</p><p><strong>输出结果：</strong><br><img src="0.png" alt="终端输出"></p><h3 id="二维动态规划问题"><a href="#二维动态规划问题" class="headerlink" title="二维动态规划问题"></a>二维动态规划问题</h3><p><strong>最长回文子串</strong></p><p>给你一个字符串 s ，找到 s 中最长的回文子串。</p><p><strong>输入：</strong>s = “babad”<br><strong>输出：</strong>“bab”<br><strong>解释：</strong>“aba” 同样是符合题意的答案。</p><p>来源：力扣（LeetCode）</p><p><strong>思路</strong></p><p>对于一个子串而言，如果它是回文串，并且长度大于 2，那么将它首尾的两个字母去除之后，它仍然是个回文串。例如对于字符串 <code>"abcba"</code>，如果我们已经知道 <code>"bcb"</code> 是回文串，那么 <code>"abcba"</code> 一定是回文串，这是因为它的首尾两个字母都是 <code>"a"</code>。也就是说一个字符串是否是回文串，取决于它的首尾两个字符是否相等以及去掉首位两个字符后的子串是否是回文串。这样我们就把原问题分解成了问题规模更小的子问题。</p><p>根据这样的思路，我们就可以用动态规划的方法解决本题。</p><p>代码实现：</p><pre class=" language-TypeScript"><code class="language-TypeScript">function longestPalindrome(s: string): string {    /*        动态规划求解步骤        1.状态定义：            dp[i][j]为true/false表示s中下标i-j之间的子串是否为回文串        2.状态转移方程            dp[i][j] == (s[i]==s[j] && dp[i+1][j-1])        3.填表并记录最大回文串的长度和起始下标求得解    */    const len: number = s.length;    if (len < 2) {        return s    }    // 记录最大长度，初始值为1    var maxLen: number = 1;    // 记录最长的回文子串的起始位置    var beginIdx: number = 0;    // 初始化二维数组dp    const dp: boolean[][] = new Array(len).fill(-1).map(() => []);    // for (let i: number = 0; i < len; i++) {    //     dp[i] = new Array(len);    // }    // 将对角线上的元素置为true    for (let i: number = 0; i < len; i++) {        dp[i][i] = true;    }    // 填表规则：先一列一列的填写，再一行一行的填，保证左下方的单元格先填    for (let j: number = 1; j < len; j++) {        for (let i: number = 0; i < j; i++) {            if (s[i] !== s[j]) {                dp[i][j] = false;            } else {                // 头尾指针相等时                if (j - i < 3) {                    // 如果头尾去掉以后没有字符剩余，或者剩下一个字符的时候，肯定是回文串                    dp[i][j] = true;                } else {                    // 状态转移                    dp[i][j] = dp[i + 1][j - 1];                }            }            // s[i...j]是回文串时判断是否是最长回文子串            if (dp[i][j] && maxLen < j - i + 1) {                maxLen = j - i + 1;                beginIdx = i;            }        }    }    // 根据起始位置和长度返回结果    return s.slice(beginIdx, beginIdx + maxLen);};</code></pre>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟 DOM 和 diff 算法（下）【转】尚硅谷</title>
      <link href="/2021/vnode-diff2/"/>
      <url>/2021/vnode-diff2/</url>
      
        <content type="html"><![CDATA[<h2 id="diff-算法处理新旧节点是同一个节点时"><a href="#diff-算法处理新旧节点是同一个节点时" class="headerlink" title="diff 算法处理新旧节点是同一个节点时"></a>diff 算法处理新旧节点是同一个节点时</h2><p>本文讨论的是当新旧节点是同一个节点时，也就是节点的 sel 属性和 key 属性相等时，diff 算法更新节点的策略。</p><p>先给出程序流程图</p><p><img src="0.png" alt="程序流程图"></p><h3 id="1-新旧节点其中一个节点存在-text-属性"><a href="#1-新旧节点其中一个节点存在-text-属性" class="headerlink" title="1.新旧节点其中一个节点存在 text 属性"></a>1.新旧节点其中一个节点存在 text 属性</h3><p>节点的 text 属性中有值也就意味着 children 属性为 undefined，在所有的情况中新旧节点同时存在 children 属性是最复杂的，所以这里先实现其他的情况。</p><p><code>patchVnode.js</code></p><p>该函数的功能是对比新旧节点，更新旧节点。当新旧节点同时存在 children 属性调用 updateChildren 函数实现最小化更新。</p><pre class=" language-JS"><code class="language-JS">import createElement from "./createElement";import updateChildren from './updateChildren.js';// 对比同一个虚拟节点export default function patchVnode(oldVnode, newVnode) {    // 判断新旧vnode是否是同一个对象    if (oldVnode === newVnode) return;    // 判断新vnode有没有text属性    if (newVnode.text != undefined && (newVnode.children == undefined || newVnode.children.length == 0)) {        // 新vnode有text属性        console.log('新vnode有text属性');        if (newVnode.text != oldVnode.text) {            // 如果新虚拟节点中的text和老的虚拟节点的text不同，那么直接让新的text写入老的elm中即可。如果老的elm中是children，那么也会立即消失掉。            oldVnode.elm.innerText = newVnode.text;        }    } else {        // 新vnode没有text属性，有children        console.log('新vnode没有text属性');        // 判断老的有没有children        if (oldVnode.children != undefined && oldVnode.children.length > 0) {            // 老的有children，新的也有children，此时就是最复杂的情况。            updateChildren(oldVnode.elm, oldVnode.children, newVnode.children);        } else {            // 老的没有children，新的有children            // 清空老的节点的内容            oldVnode.elm.innerHTML = '';            // 遍历新的vnode的子节点，创建DOM，上树            for (let i = 0; i < newVnode.children.length; i++) {                let dom = createElement(newVnode.children[i]);                oldVnode.elm.appendChild(dom);            }        }    }}</code></pre><h3 id="2-新旧节点同时存在-children-属性"><a href="#2-新旧节点同时存在-children-属性" class="headerlink" title="2.新旧节点同时存在 children 属性"></a>2.新旧节点同时存在 children 属性</h3><p>diff 算法处理新旧节点同时存在 children 属性时的更新策略是该算法的精华。<br><strong>diff 算法使用了 4 个指针分别指向新节点的头和尾，旧节点的头和尾。diff 算法给出的对比策略能够在 O(n)的线性时间复杂度内找出新旧节点的差异并实现旧节点的更新。并且在对比结束后可以根据指针得到要新增加或是删除的节点。</strong></p><p>它是如何进行对比新旧节点的差异的呢？首先它会查找旧节点中是否存在与新节点相同的节点（也就是 sel 和 key 属性相同），它的查找策略是这样的。</p><p>四种命中查找：</p><ol><li>新前与旧前</li><li>新后与旧后</li><li>新后与旧前（此种情况发生了，涉及移动节点，那么新后指向的节点，移动到旧后之后）</li><li>新前与旧后（此种情况发生了，涉及移动节点，那么新前指向的节点，移动到旧前之前）</li></ol><p><img src="1.png" alt="新旧子节点对比结束时指针指向"></p><p>如果这 4 种情况都没有命中，则会在哈希表中进行查找，哈希表中存储的是旧节点 key-&gt;index(数组下标)的映射。我们知道在哈希表中查找元素的时间复杂度是 O(1)，引入哈希表的目的就在于提高查找效率。如果还是没有找到相同节点，则说明该节点是新增的节点，将该节点插入。</p><p>循环语句是<code>while(新前 &lt;= 新后 &amp;&amp; 旧前 &lt;= 就后){}</code>，所以当循环结束后要么是新节点先遍历完，旧节点中还有剩余节点未遍历，说明这些节点是要删除的节点。要么是旧节点先遍历完，新节点中还有剩余节点未遍历，说明这些节点是要新增的节点。还有一种情况是都遍历完了，则不用处理。</p><blockquote><p>注意：因为最终的渲染结果都要以 newVDOM 为准，所以移动和插入节点的位置都是根据 newVnode 中节点的位置进行的。移动、插入和删除节点都是对旧的真实 DOM 进行操作的。虚拟 DOM 的 elm 属性是连接虚拟 DOM 和真实 DOM 的桥梁。</p></blockquote><p>下面是 diff 算法的子节点更新策略的函数实现</p><p><code>updateChildren.js</code></p><pre class=" language-JS"><code class="language-JS">import patchVnode from './patchVnode.js';import createElement from './createElement.js';// 判断是否是同一个虚拟节点function checkSameVnode(a, b) {    return a.sel == b.sel && a.key == b.key;};export default function updateChildren(parentElm, oldCh, newCh) {    console.log('我是updateChildren');    console.log(oldCh, newCh);    // 旧前    let oldStartIdx = 0;    // 新前    let newStartIdx = 0;    // 旧后    let oldEndIdx = oldCh.length - 1;    // 新后    let newEndIdx = newCh.length - 1;    // 旧前节点    let oldStartVnode = oldCh[0];    // 旧后节点    let oldEndVnode = oldCh[oldEndIdx];    // 新前节点    let newStartVnode = newCh[0];    // 新后节点    let newEndVnode = newCh[newEndIdx];    let keyMap = null;    // 开始大while了    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {        console.log('★');        // 首先不是判断①②③④命中，而是要略过已经加undefined标记的东西        if (oldStartVnode == null || oldCh[oldStartIdx] == undefined) {            oldStartVnode = oldCh[++oldStartIdx];        } else if (oldEndVnode == null || oldCh[oldEndIdx] == undefined) {            oldEndVnode = oldCh[--oldEndIdx];        } else if (newStartVnode == null || newCh[newStartIdx] == undefined) {            newStartVnode = newCh[++newStartIdx];        } else if (newEndVnode == null || newCh[newEndIdx] == undefined) {            newEndVnode = newCh[--newEndIdx];        } else if (checkSameVnode(oldStartVnode, newStartVnode)) {            // 新前和旧前            console.log('①新前和旧前命中');            patchVnode(oldStartVnode, newStartVnode);            oldStartVnode = oldCh[++oldStartIdx];            newStartVnode = newCh[++newStartIdx];        } else if (checkSameVnode(oldEndVnode, newEndVnode)) {            // 新后和旧后            console.log('②新后和旧后命中');            patchVnode(oldEndVnode, newEndVnode);            oldEndVnode = oldCh[--oldEndIdx];            newEndVnode = newCh[--newEndIdx];        } else if (checkSameVnode(oldStartVnode, newEndVnode)) {            // 新后和旧前            console.log('③新后和旧前命中');            patchVnode(oldStartVnode, newEndVnode);            // 当③新后与旧前命中的时候，此时要移动节点。移动新前指向的这个节点到老节点的旧后的后面            // 如何移动节点？？只要你插入一个已经在DOM树上的节点，它就会被移动            parentElm.insertBefore(oldStartVnode.elm, oldEndVnode.elm.nextSibling);            oldStartVnode = oldCh[++oldStartIdx];            newEndVnode = newCh[--newEndIdx];        } else if (checkSameVnode(oldEndVnode, newStartVnode)) {            // 新前和旧后            console.log('④新前和旧后命中');            patchVnode(oldEndVnode, newStartVnode);            // 当④新前和旧后命中的时候，此时要移动节点。移动新前指向的这个节点到老节点的旧前的前面            parentElm.insertBefore(oldEndVnode.elm, oldStartVnode.elm);            // 如何移动节点？？只要你插入一个已经在DOM树上的节点，它就会被移动            oldEndVnode = oldCh[--oldEndIdx];            newStartVnode = newCh[++newStartIdx];        } else {            // 四种命中都没有命中            // 制作keyMap一个映射对象，这样就不用每次都遍历老对象了。            if (!keyMap) {                keyMap = {};                // 从oldStartIdx开始，到oldEndIdx结束，创建keyMap映射对象                for (let i = oldStartIdx; i <= oldEndIdx; i++) {                    const key = oldCh[i].key;                    if (key != undefined) {                        keyMap[key] = i;                    }                }            }            console.log(keyMap);            // 寻找当前这项（newStartIdx）这项在keyMap中的映射的位置序号            const idxInOld = keyMap[newStartVnode.key];            console.log(idxInOld);            if (idxInOld == undefined) {                // 判断，如果idxInOld是undefined表示它是全新的项                // 被加入的项（就是newStartVnode这项)现不是真正的DOM节点                parentElm.insertBefore(createElement(newStartVnode), oldStartVnode.elm);            } else {                // 如果不是undefined，不是全新的项，而是要移动                const elmToMove = oldCh[idxInOld];                patchVnode(elmToMove, newStartVnode);                // 把这项设置为undefined，表示我已经处理完这项了                oldCh[idxInOld] = undefined;                // 移动，调用insertBefore也可以实现移动。                parentElm.insertBefore(elmToMove.elm, oldStartVnode.elm);            }            // 指针下移，只移动新的头            newStartVnode = newCh[++newStartIdx];        }    }    // 继续看看有没有剩余的。循环结束了start还是比old小    if (newStartIdx <= newEndIdx) {        console.log('new还有剩余节点没有处理，要加项。要把所有剩余的节点，都要插入到oldStartIdx之前');        // 遍历新的newCh，添加到老的没有处理的之前        for (let i = newStartIdx; i <= newEndIdx; i++) {            // insertBefore方法可以自动识别null，如果是null就会自动排到队尾去。和appendChild是一致了。            // newCh[i]现在还没有真正的DOM，所以要调用createElement()函数变为DOM            parentElm.insertBefore(createElement(newCh[i]), oldCh[oldStartIdx].elm);        }    } else if (oldStartIdx <= oldEndIdx) {        console.log('old还有剩余节点没有处理，要删除项');        // 批量删除oldStart和oldEnd指针之间的项        for (let i = oldStartIdx; i <= oldEndIdx; i++) {            if (oldCh[i]) {                parentElm.removeChild(oldCh[i].elm);            }        }    }};</code></pre><p><strong>总结：Diff 算法是一种对比算法。该算法能够在线性的时间复杂度内找出旧虚拟 DOM 和新虚拟 DOM 的差异，对比出是哪个虚拟节点更改了，只更新这个虚拟节点所对应的真实节点，而不影响其他没发生变化的节点，提高 DOM 的复用，实现真实 DOM 的最小量更新，进而提高渲染效率。</strong></p><p><strong>本文主要介绍了虚拟 dom 和 diff 算法相关的 patchVnode 函数、updateChildren 函数并进行了简单实现，处理的是新旧节点是同一个节点的情况。函数的实现并非官方源码，只对大体的逻辑流程进行了代码实现，而忽略了很多细节问题，仅可作学习使用。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟 DOM 和 diff 算法（上）【转】尚硅谷</title>
      <link href="/2021/vnode-diff/"/>
      <url>/2021/vnode-diff/</url>
      
        <content type="html"><![CDATA[<h3 id="1-真实-DOM-和虚拟-DOM"><a href="#1-真实-DOM-和虚拟-DOM" class="headerlink" title="1.真实 DOM 和虚拟 DOM"></a>1.真实 DOM 和虚拟 DOM</h3><p>真实 DOM 是 html 页面中的 DOM 元素。虚拟 DOM 是用 JavaScript 对象描述 DOM 的层次结构。DOM 中的一切属性都在虚拟 DOM 中有对应的属性。<br>一个虚拟 DOM 的属性如下：<br><img src="0.png" alt="VirtualNode"></p><h3 id="2-h-函数"><a href="#2-h-函数" class="headerlink" title="2.h 函数"></a>2.h 函数</h3><p>snabbdom 是著名的虚拟 DOM 库，是 diff 算法的鼻祖，Vue 源码借鉴了 snabbdom；</p><p>官方 git：<a href="https://github.com/snabbdom/snabbdom">https://github.com/snabbdom/snabbdom</a></p><p>h 函数用来产生虚拟节点（vnode），比如像这样调用 h 函数，</p><p><code>h('a', { props: { href: 'http://www.baidu.com' }}, '百度一下')</code></p><p>得到的 virtual Node 如下：</p><p><img src="1.png" alt="vnode"></p><p>当然 h 函数也可以嵌套使用，比如这样嵌套使用 h 函数：</p><pre class=" language-JS"><code class="language-JS">h('ul', {}, [ h('li', {}, '牛奶'),h('li', {}, '咖啡'),h('li', {}, '可乐')]);</code></pre><p>将得到这样的虚拟 DOM 树：</p><pre class=" language-JS"><code class="language-JS">{"sel": "ul","data": {},"children": [ { "sel": "li", "text": "牛奶" },{ "sel": "li", "text": "咖啡" },{ "sel": "li", "text": "可乐" } ] }</code></pre><p>模仿源码简单实现一个 h 函数，</p><p><code>vnode.js</code></p><pre class=" language-JS"><code class="language-JS">// 该函数的作用就是把传入的5个参数组合成对象返回export default function(sel, data, children, text, elm) {    const key = data.key;    return {        sel, data, children, text, elm, key    };}</code></pre><p><code>h.js</code></p><pre class=" language-JS"><code class="language-JS">import vnode from './vnode.js';// 编写一个低配版本的h函数，这个函数必须接受3个参数，缺一不可// 相当于它的重载功能较弱。// 也就是说，调用的时候形态必须是下面的三种之一：// 形态① h('div', {}, '文字')// 形态② h('div', {}, [])// 形态③ h('div', {}, h())export default function h(sel, data, c) {    // 检查参数的个数    if (arguments.length != 3)        throw new Error('h函数必须传入3个参数，我们是低配版h函数');    // 检查参数c的类型    if (typeof c == 'string' || typeof c == 'number') {        // 说明现在调用h函数是形态①        return vnode(sel, data, undefined, c, undefined);    } else if (Array.isArray(c)) {        // 说明现在调用h函数是形态②        let children = [];        // 遍历c，收集children，遍历的时候数组中各项已经由h函数生成了vnode        for (let i = 0; i < c.length; i++) {            // 检查c[i]必须是一个由h函数生成的vnode            if (!(typeof c[i] == 'object' && c[i].hasOwnProperty('sel')))                throw new Error('传入的数组参数中有项不是h函数');            children.push(c[i]);        }        // 循环结束了，就说明children收集完毕了，此时可以返回虚拟节点了，它有children属性的        return vnode(sel, data, children, undefined, undefined);    } else if (typeof c == 'object' && c.hasOwnProperty('sel')) {        // 说明现在调用h函数是形态③        // 即，传入的c是唯一的children。        let children = [c];        return vnode(sel, data, children, undefined, undefined);    } else {        throw new Error('传入的第三个参数类型不对');    }};</code></pre><h3 id="3-patch-函数"><a href="#3-patch-函数" class="headerlink" title="3.patch 函数"></a>3.patch 函数</h3><p><code>patch</code>函数用来更新真实 DOM 节点，该函数传入两个参数，一个是旧的 vnode，一个是新的 vnode。</p><p><img src="2.png" alt="patch 函数"></p><p>diff 处理新旧节点不是同一个节点时会直接删除旧的 dom，并插入新的 dom。如何定义“同一个节点”？旧节点的 sel 属性要和新节点的 sel 属性相同且旧节点的 key 要和新节点的 key 相同。key 属性是节点的唯一标识。</p><p>来看一下源码中对同一节点的定义</p><pre class=" language-JS"><code class="language-JS">function sameVnode(vnode1, vnode2) {    var _a, _b;    const isSameKey = vnode1.key === vnode2.key;    const isSameIs = ((_a = vnode1.data) === null || _a === void 0 ? void 0 : _a.is) === ((_b = vnode2.data) === null || _b === void 0 ? void 0 : _b.is);    const isSameSel = vnode1.sel === vnode2.sel;    return isSameSel && isSameKey && isSameIs;}</code></pre><p><code>patch.js</code></p><pre class=" language-JS"><code class="language-JS">import vnode from './vnode.js';import createElement from './createElement.js';import patchVnode from './patchVnode.js'export default function patch(oldVnode, newVnode) {    // 判断传入的第一个参数，是DOM节点还是虚拟节点？    if (oldVnode.sel == '' || oldVnode.sel == undefined) {        // 传入的第一个参数是DOM节点，此时要包装为虚拟节点        oldVnode = vnode(oldVnode.tagName.toLowerCase(), {}, [], undefined, oldVnode);    }    // 判断oldVnode和newVnode是不是同一个节点    if (oldVnode.key == newVnode.key && oldVnode.sel == newVnode.sel) {        console.log('是同一个节点');        // 调用patchVnode函数进行diff        patchVnode(oldVnode, newVnode);    } else {        console.log('不是同一个节点，暴力插入新的，删除旧的');        // 调用createElement函数，该函数将传入的虚拟dom转为真实dom返回        let newVnodeElm = createElement(newVnode);        // 插入到旧节点之前        oldVnode.elm.parentNode.insertBefore(newVnodeElm, oldVnode.elm);        // 删除旧节点        oldVnode.elm.parentNode.removeChild(oldVnode.elm);    }};</code></pre><h3 id="4-createElement-函数"><a href="#4-createElement-函数" class="headerlink" title="4.createElement 函数"></a>4.createElement 函数</h3><p>createElement 函数用于将虚拟 dom 转为真实 dom。</p><p><code>createElement.js</code></p><pre class=" language-JS"><code class="language-JS">// 该函数的作用就是将传入的虚拟dom转为真实dom返回export default function createElement(vnode) {    // 创建一个真实DOM节点，这个节点现在还是孤儿节点    let domNode = document.createElement(vnode.sel);    // 判断该节点是否有children    if (vnode.text != '' && (vnode.children == undefined || vnode.children.length == 0)) {        // 文本节点        domNode.innerText = vnode.text;    } else if (Array.isArray(vnode.children) && vnode.children.length > 0) {        // 它内部有子节点，就要递归创建子节点        for (let i = 0; i < vnode.children.length; i++) {            // 得到当前这个children            let ch = vnode.children[i];            // 创建出它的DOM，一旦调用createElement意味着：创建出DOM了，并且它的elm属性指向了创建出的DOM，但是还没有上树，是一个孤儿节点。            let chDOM = createElement(ch);            // 将子节点添加到父节点上，操作的是真实dom            domNode.appendChild(chDOM);        }    }    // 添加elm属性，elm属性是一个真实DOM对象    vnode.elm = domNode;    return vnode.elm;};</code></pre><p><strong>本文主要介绍了虚拟 dom 和 diff 算法相关的 h 函数、patch 函数、createElement 函数并进行了简单实现，处理的是新旧节点不是同一个节点的情况。函数的实现并非官方源码，只对大体的逻辑流程进行了代码实现，而忽略了很多细节问题，仅可作学习使用。</strong></p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vue 2数据响应式原理</title>
      <link href="/2021/datareactive/"/>
      <url>/2021/datareactive/</url>
      
        <content type="html"><![CDATA[<h3 id="0-数据响应式的概念"><a href="#0-数据响应式的概念" class="headerlink" title="0.数据响应式的概念"></a>0.数据响应式的概念</h3><p>使用 Vue 时，我们只需要修改数据(state)，视图就能够获得相应的更新，这就是响应式系统。要实现一个自己的响应式系统，我们首先要清楚做什么：</p><ol><li>数据劫持：当数据变化时，我们可以做一些特定的事情</li><li>依赖收集：我们要知道那些视图层的内容(DOM)依赖了哪些数据(state)</li><li>派发更新：数据变化后，如何通知依赖这些数据的 DOM</li></ol><p>接下来，我们来一步步实现一个响应式系统</p><h3 id="1-数据劫持"><a href="#1-数据劫持" class="headerlink" title="1.数据劫持"></a>1.数据劫持</h3><h4 id="对对象的监测"><a href="#对对象的监测" class="headerlink" title="对对象的监测"></a>对对象的监测</h4><p>首先实现一个简单的数据劫持</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// defineReactive方法的作用是将数据变成响应式的，给对象上的每一个属性设置getter和setter</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> val <span class="token operator">=</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>    enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"你在访问"</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"属性"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token keyword">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"你在改变"</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"属性"</span><span class="token punctuation">,</span> newVal<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> newVal<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>      val <span class="token operator">=</span> newVal<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>定义<code>var obj = { a: 3 }</code>，再调用 defineReactive(obj,a)，这样在控制台查看 obj 的 a 属性时就会输出<code>"你在访问a属性, 3"</code>，对 a 属性重新赋值时就会输出<code>你在改变a属性, newVal</code>。这样就实现了简单的数据劫持。</p><p>需要注意的是这里其实使用了闭包，在 get 和 set 方法中 val 的值是函数外部的所以形成了闭包，可以在控制台查看 a 属性的 get 方法，形成的闭包就在它的 Scopes 属性中，结果如下：</p><p><img src="0.png" alt="Closure"></p><p>接着我们要遍历 obj 的属性，给每个属性都调用<code>defineReactive()</code>方法，并实现对象的深度监测。创建一个 observe 函数如下</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> Observer <span class="token keyword">from</span> <span class="token string">"./Observer.js"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// observe函数的作用是返回一个Observer实例ob</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">observe</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value <span class="token operator">!==</span> <span class="token string">"object"</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>  <span class="token keyword">var</span> ob<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 如果对象存在__ob__属性则说明已经实现了响应式，无需再生成Observer实例</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> value<span class="token punctuation">.</span>__ob__ <span class="token operator">!==</span> <span class="token string">"undefined"</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    ob <span class="token operator">=</span> value<span class="token punctuation">.</span>__ob__<span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>    ob <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Observer</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> ob<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>observe 的函数的作用是对 object 类型的数据调用 Observer 类的构造方法实现响应式。注意这句代码<code>if (typeof value !== "object") return;</code>，这是对对象深度监测的结束条件。这里返回的 ob 是一个 Observer 实例，可以先暂且不管。</p><p>Observer 类的实现如下：</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> def <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./utils.js"</span><span class="token punctuation">;</span><span class="token keyword">import</span> defineReactive <span class="token keyword">from</span> <span class="token string">"./defineReactive"</span><span class="token punctuation">;</span><span class="token keyword">import</span> observe <span class="token keyword">from</span> <span class="token string">"./observe.js"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Observer类的作用是是在每一层对象上生成一个__ob__属性，值为新创建的Observer实例ob，</span><span class="token comment" spellcheck="true">// 可以理解为凡是有该属性的对象我们都可以监测到它的变化</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">def</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token string">"__ob__"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">defineReactive</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>ES6 的 class 可以看作只是一个语法糖，它本质上和 ES5 的构造函数一样的。Observer 类的构造方法中调用了<code>walk()</code>方法遍历传入对象上的属性并调用<code>defineReactive()</code>方法实现数据劫持。这里的<code>def()</code>方法会在每一层对象上生成一个 ob 属性，值为新创建的 Observer 实例 ob，可以理解为凡是有该属性的对象我们都可以监测到它的变化。</p><p>def 方法的实现</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">const</span> def <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> enumerable<span class="token punctuation">)</span> <span class="token punctuation">{</span>  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>    value<span class="token punctuation">,</span>    enumerable<span class="token punctuation">,</span>    writable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>接着我们还要在 defineReactive 函数中做一些修改，</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> observe <span class="token keyword">from</span> <span class="token string">"./observe"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// defineReactive方法的作用是将数据变成响应式的，给对象上的每一个属性设置getter和setter</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">var</span> val <span class="token operator">=</span> data<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 这里会递归</span>  <span class="token function">observe</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>  Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">,</span> <span class="token punctuation">{</span>    enumerable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    configurable<span class="token punctuation">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>    <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"你在访问"</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"属性"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> val<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token keyword">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"你在改变"</span> <span class="token operator">+</span> key <span class="token operator">+</span> <span class="token string">"属性"</span><span class="token punctuation">,</span> newVal<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>val <span class="token operator">===</span> newVal<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>      val <span class="token operator">=</span> newVal<span class="token punctuation">;</span>      <span class="token function">observe</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>首先会判断数据是否为对象，如果是对象则调用 observe 方法进行递归调用，直到这里的 val 不是 object 类型的数据（递归的终止条件），再对数据进行 getter 和 setter，然后递归函数返回上一层。。。这样就实现对对象的深度监听。这里还要考虑到 set 方法中新设置的值可能为对象，所以要对新设置的 val 进行 observe 数据劫持。</p><p>可以看出，主要的三个函数的调用关系如下：</p><p><img src="1.png" alt="函数关系图"></p><p>至此我们就对对象的所有属性进行了深度监测。通过对源码的分析，我们也能理解了为什么官网说 Vue 无法检测 property 的添加或移除。就是由于 Vue 会在初始化实例时对 property 执行 getter/setter 转化，所以 property 必须在 data 对象上存在才能让 Vue 将它转换为响应式的。后添加的 property 没有 getter/setter，property 的移除也无法触发 getter/setter。</p><h4 id="对数组的监测"><a href="#对数组的监测" class="headerlink" title="对数组的监测"></a>对数组的监测</h4><p>Vue 对数组的监测并不是像对象那样监测它身上的每一个属性（每一个数组项），据 Vue 的作者说是因为性能问题，所以 Vue 对数组的监测方法是重写了会造成数组变化的<code>'push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'</code>这七种原生的数组方法，也就是说数组调用这七种方法才能被 vue 监测到。先来看一张图</p><p><img src="2.png" alt="原型关系图"></p><p>重写原生数组方法的实现如下<code>array.js</code></p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> def <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./utils.js"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 以Array.prototype为原型创建arrayMethods对象</span><span class="token comment" spellcheck="true">// arrayMethods对象会继承Array.prototype上的所有方法</span><span class="token keyword">export</span> <span class="token keyword">const</span> arrayMethods <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> arrayPrototype <span class="token operator">=</span> Array<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span class="token keyword">const</span> methodsNeedChange <span class="token operator">=</span> <span class="token punctuation">[</span>  <span class="token string">"push"</span><span class="token punctuation">,</span>  <span class="token string">"pop"</span><span class="token punctuation">,</span>  <span class="token string">"shift"</span><span class="token punctuation">,</span>  <span class="token string">"unshift"</span><span class="token punctuation">,</span>  <span class="token string">"splice"</span><span class="token punctuation">,</span>  <span class="token string">"sort"</span><span class="token punctuation">,</span>  <span class="token string">"reverse"</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 遍历上述数组方法名，依次将上述重写后的数组方法添加到arrayMethods对象上</span>methodsNeedChange<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>methodsName<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 备份原来的数组方法</span>  <span class="token keyword">var</span> original <span class="token operator">=</span> arrayPrototype<span class="token punctuation">[</span>methodsName<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 将重写后的方法定义到arrayMethods对象上，def 函数的第三个参数就是重写后的方法</span>  <span class="token function">def</span><span class="token punctuation">(</span>    arrayMethods<span class="token punctuation">,</span>    methodsName<span class="token punctuation">,</span>    <span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span> <span class="token punctuation">{</span>      console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">"数组"</span> <span class="token operator">+</span> methodsName <span class="token operator">+</span> <span class="token string">"方法重写成功!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 调用数组原始方法，并改变this指向为调用该方法的数组，传入参数args，返回执行结果</span>      <span class="token keyword">const</span> result <span class="token operator">=</span> original<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 数组身上有一个__ob__属性，它是Observer实例，继承了Observer类的方法</span>      <span class="token keyword">const</span> ob <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>__ob__<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// push, unshift, splice方法会添加新数据需要进行特殊处理</span>      <span class="token comment" spellcheck="true">// inserted存储新添加的数据</span>      <span class="token keyword">let</span> inserted<span class="token punctuation">;</span>      <span class="token keyword">switch</span> <span class="token punctuation">(</span>methodsName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token string">"push"</span><span class="token punctuation">:</span>        <span class="token keyword">case</span> <span class="token string">"unshift"</span><span class="token punctuation">:</span>          inserted <span class="token operator">=</span> args<span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> <span class="token string">"splice"</span><span class="token punctuation">:</span>          inserted <span class="token operator">=</span> args<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">break</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment" spellcheck="true">// 对添加的数据执行observe</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>inserted<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ob<span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>inserted<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    <span class="token boolean">false</span>  <span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>重写完数组的上述 7 种方法外，我们还需要将这些重写的方法应用到数组上，因此在 Observer 构造函数中，在监听数据时会判断数据类型是否为数组。当为数组时，则直接将当前数据的原型<code>__proto__</code>指向重写后的数组方法对象<code>arrayMethods</code>，并对数组的每一项执行<code>observe</code>。</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> <span class="token punctuation">{</span> def <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./utils.js"</span><span class="token punctuation">;</span><span class="token keyword">import</span> defineReactive <span class="token keyword">from</span> <span class="token string">"./defineReactive"</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token punctuation">{</span> arrayMethods <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">"./array.js"</span><span class="token punctuation">;</span><span class="token keyword">import</span> observe <span class="token keyword">from</span> <span class="token string">"./observe.js"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">def</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> <span class="token string">"__ob__"</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断是否为数组，是则将该数组的原型指向重写后的数组方法对象</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      value<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> arrayMethods<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 对数组的每一项进行observe</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">observeArray</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">walk</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> k <span class="token keyword">in</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">defineReactive</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> k<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span>  <span class="token function">observeArray</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> l <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> l<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">observe</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>至此我们就实现对数组的监测，也明白了为什么当我们利用索引直接设置一个数组项时或者修改数组的长度时 vue 不能监测到。</p><h3 id="2-依赖收集-amp-amp-派发更新"><a href="#2-依赖收集-amp-amp-派发更新" class="headerlink" title="2.依赖收集 &amp;&amp; 派发更新"></a>2.依赖收集 &amp;&amp; 派发更新</h3><p>为了实现当数据发生变化时只更新与这个数据有关的 DOM 结构，我们就需要使用订阅-发布模式。</p><p><img src="3.png" alt="发布订阅模式"></p><p>从图我们可以简单理解：Dep 可以看做是书店，Watcher 就是书店订阅者，而 Observer 就是书店的书，订阅者在书店订阅书籍，就可以添加订阅者信息，一旦有新书就会通过书店给订阅者发送消息。</p><p>首先实现 Watcher 类</p><pre class=" language-js"><code class="language-js"><span class="token keyword">import</span> Dep <span class="token keyword">from</span> <span class="token string">"./Dep"</span><span class="token punctuation">;</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Watcher</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> expression<span class="token punctuation">,</span> cb<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// data: 数据对象，如obj</span>    <span class="token comment" spellcheck="true">// expression：表达式，如a.b.c，根据data和expression就可以获取watcher依赖的数据</span>    <span class="token comment" spellcheck="true">// cb：依赖变化时触发的回调</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>expression <span class="token operator">=</span> expression<span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>cb <span class="token operator">=</span> cb<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 初始化watcher实例时订阅数据</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 进入依赖收集阶段，把实例化的watcher存在Dep.target中，在getter时取出放入dep.subs数组中</span>    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> value <span class="token operator">=</span> <span class="token function">parsePath</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 依赖收集完成后把Dep.target重置为null</span>    Dep<span class="token punctuation">.</span>target <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> value<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment" spellcheck="true">// 当收到数据变化的消息时执行该方法，从而调用cb回调完成视图更新</span>  <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 对依赖的数据进行更新</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> <span class="token function">parsePath</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>data<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>expression<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">cb</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">parsePath</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> expression<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">const</span> segments <span class="token operator">=</span> expression<span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> segments<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>obj<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>    obj <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> obj<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里的 watcher 可以看作是一个插值表达式，一个数据可能会被多个 watcher 订阅，我们要创建一个数组把它们收集起来。上面代码可以看到需要在 getter 方法执行时收集 watcher，所以在<code>defineReactive</code>方法中添加操作</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">// 这是省略后的代码</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span> <span class="token function">defineReactive</span><span class="token punctuation">(</span>data<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 创建dep实例对象，用来为每一个数据存储watcher，dep会存在闭包中</span>  <span class="token keyword">const</span> dep <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Dep</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 这里的Dep.target存放了watcher实例</span>    <span class="token comment" spellcheck="true">// 如果处在watcher收集阶段则调用depend方法将该watcher放入dep.subs数组中</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">{</span>      dep<span class="token punctuation">.</span><span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> val<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span>  <span class="token keyword">set</span><span class="token punctuation">(</span>newVal<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 发布订阅模式，val发生变化时通知dep</span>    dep<span class="token punctuation">.</span><span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Dep 类用来依赖收集和派发更新，即收集 watcher 和当数据变化时通知 watcher，它的实现如下</p><pre class=" language-js"><code class="language-js"><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">Dep</span> <span class="token punctuation">{</span>  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">depend</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">addSub</span><span class="token punctuation">(</span>Dep<span class="token punctuation">.</span>target<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">const</span> subs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">...</span><span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">]</span><span class="token punctuation">;</span>    subs<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token function">addSub</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>subs<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>sub<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>至此我们就完成了依赖的收集和派发更新，就是把每一个数据的订阅者（watcher）收集起来，放在 dep.subs 数组中。当数据发生变化时通知 Dep，Dep 再遍历 subs 数组通知每一个 watcher 从而更新视图。具体实现可详细阅读上面的代码。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li>Vue 在 Init 初始化的时候会对 data 执行 observe 方法，在 Observer 类的构造器中用了 <code>Object.defineProperty</code> 方法实现了 data 的 <code>getter/setter</code> 操作，将 data 变为可以成观察的，这样就完成了数据劫持。</li><li>接着在模板编译过程中的指令或者数据绑定（插值）都会实例化一个 Watcher 实例，实例化过程中会触发 <code>get() </code>方法将该实例存放在 <code>Dep.target</code> 中，接着会对依赖的数据进行求值，求值就会触发数据的<code>getter</code>，在<code>getter</code>方法中就会取出<code>Dep.target</code>的值从而将依赖该数据的 watcher 存放在<code>dep.subs</code>数组中，这样就完成了依赖收集。</li><li>最后当 data 中某个属性值变化时，我们在<code>setter</code>使用<code>dep.notify</code>方法通知 Dep，<code>dep.notify</code>方法则会遍历 subs 数组通知依赖该数据的所有 watcher 执行<code>update()</code>方法派发更新，从而完成视图的更新。</li></ol><p><strong><em>以上我们就对 Vue 的响应式原理中的部分代码进行了简单的分析和实现，有很多地方纯属个人理解，作者目前水平有限，文章一些地方可能还存在不足或有误，不足为训。</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> Web前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vue </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vuex Note</title>
      <link href="/2021/vuexnote/"/>
      <url>/2021/vuexnote/</url>
      
        <content type="html"><![CDATA[<h2 id="Vuex"><a href="#Vuex" class="headerlink" title="Vuex"></a>Vuex</h2><h3 id="1-概念"><a href="#1-概念" class="headerlink" title="1.概念"></a>1.概念</h3><p>​ 在 Vue 中实现集中式状态（数据）管理的一个 Vue 插件，对 vue 应用中多个组件的共享状态进行集中式的管理（读/写），也是一种组件间通信的方式，且适用于任意组件间通信。</p><h3 id="2-何时使用？"><a href="#2-何时使用？" class="headerlink" title="2.何时使用？"></a>2.何时使用？</h3><p>​ 多个组件需要共享数据时</p><h3 id="3-工作原理图"><a href="#3-工作原理图" class="headerlink" title="3.工作原理图"></a>3.工作原理图</h3><p><img src="vuex.png" alt="Vuex 原理图（来源于官网）"></p><h3 id="4-搭建-vuex-环境"><a href="#4-搭建-vuex-环境" class="headerlink" title="4.搭建 vuex 环境"></a>4.搭建 vuex 环境</h3><ol><li><p>创建文件：<code>src/store/index.js</code></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//引入Vue核心库</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引入Vuex</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">"vuex"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//应用Vuex插件</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//准备actions对象——响应组件中用户的动作</span><span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//准备mutations对象——修改state中的数据</span><span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//准备state对象——保存具体的数据</span><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建并暴露store</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  actions<span class="token punctuation">,</span>  mutations<span class="token punctuation">,</span>  state<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>在<code>main.js</code>中创建 vm 时传入<code>store</code>配置项</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//引入store</span><span class="token keyword">import</span> store <span class="token keyword">from</span> <span class="token string">"./store"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建vm</span><span class="token keyword">new</span> <span class="token class-name">Vue</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  el<span class="token punctuation">:</span> <span class="token string">"#app"</span><span class="token punctuation">,</span>  render<span class="token punctuation">:</span> <span class="token punctuation">(</span>h<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token function">h</span><span class="token punctuation">(</span>App<span class="token punctuation">)</span><span class="token punctuation">,</span>  store<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ol><h3 id="5-基本使用"><a href="#5-基本使用" class="headerlink" title="5.基本使用"></a>5.基本使用</h3><ol><li><p>初始化数据、配置<code>actions</code>、配置<code>mutations</code>，操作文件<code>store.js</code></p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//引入Vue核心库</span><span class="token keyword">import</span> Vue <span class="token keyword">from</span> <span class="token string">"vue"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引入Vuex</span><span class="token keyword">import</span> Vuex <span class="token keyword">from</span> <span class="token string">"vuex"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//引用Vuex</span>Vue<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span>Vuex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">const</span> actions <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//响应组件中的dispatch，传入的第一个参数context有commit,state,dispatch等属性</span>  <span class="token function">jia</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    context<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">"JIA"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">const</span> mutations <span class="token operator">=</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">//执行mutate，改变state中的状态</span>  <span class="token function">JIA</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    state<span class="token punctuation">.</span>sum <span class="token operator">+</span><span class="token operator">=</span> value<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//初始化数据</span><span class="token keyword">const</span> state <span class="token operator">=</span> <span class="token punctuation">{</span>  sum<span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//创建并暴露store</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  actions<span class="token punctuation">,</span>  mutations<span class="token punctuation">,</span>  state<span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>组件中读取 vuex 中的数据：<code>this.$store.state.sum</code></p></li><li><p>组件中修改 vuex 中的数据：<code>this.$store.dispatch('action中的方法名',数据)</code> 或 <code>this.$store.commit('mutations中的方法名',数据)</code></p><blockquote><p>备注：若没有网络请求或其他业务逻辑，组件中也可以直接 commit，即不写<code>dispatch</code>，直接写<code>commit</code></p></blockquote></li></ol><h3 id="6-getters-的使用"><a href="#6-getters-的使用" class="headerlink" title="6.getters 的使用"></a>6.getters 的使用</h3><ol><li><p>概念：当 state 中的数据需要经过加工后再使用时，可以使用 getters 加工。</p></li><li><p>在<code>store.js</code>中追加<code>getters</code>配置</p><pre class=" language-js"><code class="language-js"><span class="token keyword">const</span> getters <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// bigSum 可以理解为一个计算属性</span>    <span class="token function">bigSum</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> state<span class="token punctuation">.</span>sum <span class="token operator">*</span> <span class="token number">10</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//创建并暴露store</span><span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>    <span class="token operator">...</span><span class="token operator">...</span>    getters<span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>组件中读取 getters 中的数据：<code>this.$store.getters.bigSum</code></p></li></ol><h3 id="7-四个-map-方法的使用"><a href="#7-四个-map-方法的使用" class="headerlink" title="7.四个 map 方法的使用"></a>7.四个 map 方法的使用</h3><ol start="0"><li><p><strong>为什么要使用 mapXXX 方法？</strong><br>当我们在组件中操作 store 中存储的数据时不可避免的要编写大量的 computed 和 methods，这样的操作十分繁琐，而使用 mapXXX 方法能简化我们的操作。例如借助 <code>mapState()</code> 方法可以帮我们生成相应的 computed，借助 <code>mapActions()</code> 方法可以帮我们生成相应的 methods，其他的方法同理。再使用 … 扩展运算符将生成的 computed 或 methods 展开。</p></li><li><p><strong>首先需要在组件中导入 mapXXX 方法</strong><br><code>import {mapState, mapGetters, mapMutations, mapActions} from 'vuex'</code></p></li><li><p><strong>mapState 方法：</strong>用于帮助我们映射<code>state</code>中的数据为计算属性</p><pre class=" language-js"><code class="language-js">computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//（对象写法）借助mapState生成计算属性：sum、school、subject</span>     <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">{</span>sum<span class="token punctuation">:</span><span class="token string">'sum'</span><span class="token punctuation">,</span>school<span class="token punctuation">:</span><span class="token string">'school'</span><span class="token punctuation">,</span>subject<span class="token punctuation">:</span><span class="token string">'subject'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//（数组写法）借助mapState生成与state中的数据同名的计算属性：sum、school、subject</span>    <span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'sum'</span><span class="token punctuation">,</span><span class="token string">'school'</span><span class="token punctuation">,</span><span class="token string">'subject'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre></li><li><p><strong>mapGetters 方法：</strong>用于帮助我们映射<code>getters</code>中的数据为计算属性</p><pre class=" language-js"><code class="language-js">computed<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//（对象写法）借助mapGetters生成计算属性：bigSum</span>    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">{</span>bigSum<span class="token punctuation">:</span><span class="token string">'bigSum'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//（数组写法）借助mapGetters生成同名的计算属性：bigSum</span>    <span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'bigSum'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">,</span></code></pre></li><li><p><strong>mapActions 方法：</strong>用于帮助我们生成与<code>actions</code>对话的方法，即：包含<code>$store.dispatch(xxx)</code>的函数</p><pre class=" language-js"><code class="language-js">methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//（对象写法）靠mapActions生成：incrementOdd、incrementWait</span>    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">{</span>incrementOdd<span class="token punctuation">:</span><span class="token string">'jiaOdd'</span><span class="token punctuation">,</span>incrementWait<span class="token punctuation">:</span><span class="token string">'jiaWait'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//（数组写法）靠mapActions生成同名的：jiaOdd, jiaWait</span>    <span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'jiaOdd'</span><span class="token punctuation">,</span><span class="token string">'jiaWait'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre></li><li><p><strong>mapMutations 方法：</strong>用于帮助我们生成与<code>mutations</code>对话的方法，即：包含<code>$store.commit(xxx)</code>的函数</p><pre class=" language-js"><code class="language-js">methods<span class="token punctuation">:</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//（对象写法）靠mapActions生成：increment、decrement</span>    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">{</span>increment<span class="token punctuation">:</span><span class="token string">'JIA'</span><span class="token punctuation">,</span>decrement<span class="token punctuation">:</span><span class="token string">'JIAN'</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token comment" spellcheck="true">//（数组写法）靠mapMutations生成同名的methods：JIA、JIAN</span>    <span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'JIA'</span><span class="token punctuation">,</span><span class="token string">'JIAN'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">}</span></code></pre></li></ol><blockquote><p>注意：借助 mapActions 与 mapMutations 生成的 methods 需要向 actions 和 mutations 传递参数时，必须要在调用该 method 的时候传递参数。</p></blockquote><h3 id="8-模块化-命名空间"><a href="#8-模块化-命名空间" class="headerlink" title="8.模块化+命名空间"></a>8.模块化+命名空间</h3><ol><li><p>目的：让代码更好维护，让多种数据分类更加明确。</p></li><li><p>修改<code>store.js</code></p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">const</span> countAbout <span class="token operator">=</span> <span class="token punctuation">{</span>  namespaced<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//开启命名空间</span>  state<span class="token punctuation">:</span><span class="token punctuation">{</span>x<span class="token punctuation">:</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">,</span>  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  getters<span class="token punctuation">:</span> <span class="token punctuation">{</span>    <span class="token function">bigSum</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">{</span>       <span class="token keyword">return</span> state<span class="token punctuation">.</span>sum <span class="token operator">*</span> <span class="token number">10</span>    <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> personAbout <span class="token operator">=</span> <span class="token punctuation">{</span>  namespaced<span class="token punctuation">:</span><span class="token boolean">true</span><span class="token punctuation">,</span><span class="token comment" spellcheck="true">//开启命名空间</span>  state<span class="token punctuation">:</span><span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  mutations<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>  actions<span class="token punctuation">:</span> <span class="token punctuation">{</span> <span class="token operator">...</span> <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">const</span> store <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Vuex<span class="token punctuation">.</span>Store</span><span class="token punctuation">(</span><span class="token punctuation">{</span>  modules<span class="token punctuation">:</span> <span class="token punctuation">{</span>    countAbout<span class="token punctuation">:</span> countAbout<span class="token punctuation">,</span>    personAbout<span class="token punctuation">:</span> personAbout  <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre></li><li><p>开启命名空间后，组件中读取 state 数据：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//方式一：自己直接读取</span><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>state<span class="token punctuation">.</span>countAbout<span class="token punctuation">.</span>sum<span class="token comment" spellcheck="true">//方式二：借助mapState生成后再读取：</span><span class="token operator">...</span><span class="token function">mapState</span><span class="token punctuation">(</span><span class="token string">'countAbout'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'sum'</span><span class="token punctuation">,</span><span class="token string">'school'</span><span class="token punctuation">,</span><span class="token string">'subject'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p>开启命名空间后，组件中读取 getters 数据：</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//方式一：自己直接读取</span><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span>getters<span class="token punctuation">[</span><span class="token string">'countAbout/bigSum'</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">//方式二：借助mapGetters生成后再读取：</span><span class="token operator">...</span><span class="token function">mapGetters</span><span class="token punctuation">(</span><span class="token string">'countAbout'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'bigSum'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p>开启命名空间后，组件中调用 dispatch</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//方式一：自己直接dispatch</span><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">dispatch</span><span class="token punctuation">(</span><span class="token string">'personAbout/addPersonWang'</span><span class="token punctuation">,</span>person<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//方式二：借助mapActions生成后再读取：</span><span class="token operator">...</span><span class="token function">mapActions</span><span class="token punctuation">(</span><span class="token string">'personAbout'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'addPersonWang'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li><li><p>开启命名空间后，组件中调用 commit</p><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//方式一：自己直接commit</span><span class="token keyword">this</span><span class="token punctuation">.</span>$store<span class="token punctuation">.</span><span class="token function">commit</span><span class="token punctuation">(</span><span class="token string">'personAbout/ADD_PERSON'</span><span class="token punctuation">,</span>person<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//方式二：借助mapMutations生成后再读取：</span><span class="token operator">...</span><span class="token function">mapMutations</span><span class="token punctuation">(</span><span class="token string">'personAbout'</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">'ADD_PERSON'</span><span class="token punctuation">]</span><span class="token punctuation">)</span></code></pre></li></ol><hr><p><strong><em>本文章根据尚硅谷笔记整理而成</em></strong></p>]]></content>
      
      
      <categories>
          
          <category> 笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> Vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用Hexo发布一篇文章</title>
      <link href="/2021/blogwriting/"/>
      <url>/2021/blogwriting/</url>
      
        <content type="html"><![CDATA[<h2 id="新建一篇文章"><a href="#新建一篇文章" class="headerlink" title="新建一篇文章"></a>新建一篇文章</h2><p>1、在 hexo 博客目录下，进入 Git Bash 命令窗口中，输入以下命令：</p><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"我的第一篇博客文章"</span></code></pre><p>2、在博客目录下的/source/_posts/ 文件夹下，就可以看到已经生成了标题为(我的第一篇博客文章.md)的博客文件，在该文件中编辑自己的博客文章即可。</p><blockquote><p>注意：Hexo 发布的文章是 Markdown 格式的文件，需要使用 Markdown 语法进行编写。</p></blockquote><p>Markdown 语法自查：<a href="https://markdown.com.cn/">Markdown 官方教程</a></p><hr><h2 id="文章-Front-matter-配置"><a href="#文章-Front-matter-配置" class="headerlink" title="文章 Front-matter 配置"></a>文章 Front-matter 配置</h2><p>Front-matter 选项中的所有内容均为非必填的。但是建议至少填写 title 和 date 的值。</p><h3 id="基本配置示例"><a href="#基本配置示例" class="headerlink" title="基本配置示例"></a>基本配置示例</h3><pre class=" language-markdown"><code class="language-markdown">title: 使用 Hexo 发布一篇文章date: 2021-11-20 21：30：00author: Tulongimg: /source/images/xxx.jpgsummary: 记录了 Hexo 发布一篇文章的一般流程tags:<span class="token list punctuation">-</span> Hexo<span class="token list punctuation">-</span> Markdown  categories: 博客</code></pre><h3 id="详细配置"><a href="#详细配置" class="headerlink" title="详细配置"></a>详细配置</h3><p>参见：<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#%E6%96%87%E7%AB%A0-front-matter-%E4%BB%8B%E7%BB%8D">Front-matter 选项详解</a></p><hr><h2 id="用-Markdown-语法编写正文部分"><a href="#用-Markdown-语法编写正文部分" class="headerlink" title="用 Markdown 语法编写正文部分"></a>用 Markdown 语法编写正文部分</h2><p>像这样：<br><img src="0.png" alt="示例"></p><h3 id="在文章中插入图片的方法"><a href="#在文章中插入图片的方法" class="headerlink" title="在文章中插入图片的方法"></a>在文章中插入图片的方法</h3><p><strong><em>1. 在本地引用</em></strong></p><p>绝对路径：当 Hexo 项目中只用到少量图片时，可以将图片统一放在 source/images 文件夹中，通过 markdown 语法访问它们。这种方式引入的图片既可以在首页内容中访问到，也可以在文章正文中访问到。像下面这样引用：</p><p><code>![图片alt](/images/image.jpg "图片title")</code></p><p>相对路径：图片还可以放在文章自己的文件夹中。将 _config.yml 文件中的配置项 post_asset_folder 设为 true 后，执行命令<code>$ hexo new post_name</code>，在 source/_posts 中会生成文章 post_name.md 和同名文件夹 post_name 。将图片资源放在 post_name 中，文章就可以使用相对路径引用图片资源了。像下面这样引入：</p><p><code>![图片alt](image.jpg)</code></p><p>这样引入的图片只能在文章中显示，但无法在首页中正常显示。如果希望图片在文章和首页中同时显示，可以使用标签插件语法。像这样：</p><p><code>{% asset_img image.jpg This is an image %}</code></p><p><strong><em>2. CDN 引用</em></strong></p><p>除了在本地存储图片，还可以将图片上传到一些免费的 CDN 服务中。比如 Cloudinary 提供的图片 CDN 服务，在 Cloudinary 中上传图片后，会生成对应的 url 地址，将地址直接拿来引用即可。</p><hr><h2 id="启动服务器，本地测试"><a href="#启动服务器，本地测试" class="headerlink" title="启动服务器，本地测试"></a>启动服务器，本地测试</h2><p><code>$ hexo server</code></p><hr><h2 id="生成静态文件并部署到-GitHub-上"><a href="#生成静态文件并部署到-GitHub-上" class="headerlink" title="生成静态文件并部署到 GitHub 上"></a>生成静态文件并部署到 GitHub 上</h2><p>想要发布的文章在本地预览无误后，在 Git Bash 命令窗口依次执行如下命令：</p><p><code>$ hexo clean</code></p><p><code>$ hexo generate</code></p><p><code>$ hexo deploy</code></p><p>执行完毕后在浏览器访问自己的博客域名，即可看到刚才发布的文章。</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客文章</title>
      <link href="/2021/myfirstblog/"/>
      <url>/2021/myfirstblog/</url>
      
        <content type="html"><![CDATA[<p>javascript 是一门充满活力、简单易用的语言，又是一门具有许多复杂微妙技术的语言。即使是经验丰富的 javascript 开发者，如果没有认真学习的话，也无法真正理解它们，这就是 javascript 的矛盾之处。由于 javascript 不必理解就可以使用，因此通常来说很难真正理解语言本身，这就是我们面临的挑战。不满足于只是让代码正常工作，而是想要弄清楚为什么，勇于挑战这条崎岖颠簸的少有人走的路，拥抱整个 javascript…</p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/2021/hello-world/"/>
      <url>/2021/hello-world/</url>
      
        <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token string">"My New Post"</span></code></pre><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><pre class=" language-bash"><code class="language-bash">$ hexo server</code></pre><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><pre class=" language-bash"><code class="language-bash">$ hexo generate</code></pre><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><pre class=" language-bash"><code class="language-bash">$ hexo deploy</code></pre><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
